From 616d4effe5c06236c98e483bed4a94f47f2c4e72 Mon Sep 17 00:00:00 2001
From: Timofei Nikitin <tim.a.nikitin@yandex.ru>
Date: Sun, 12 Feb 2023 15:09:26 +0300
Subject: [PATCH] Copy bds module from edk2

---
 .../BoardTiogaPass/CoreDxeInclude.dsc         |    2 +-
 .../BoardTiogaPass/CoreUefiBootInclude.fdf    |    2 +-
 .../MdeModulePkg/Universal/BdsDxe/Bds.h       |  107 ++
 .../MdeModulePkg/Universal/BdsDxe/BdsDxe.inf  |  106 ++
 .../MdeModulePkg/Universal/BdsDxe/BdsDxe.uni  |   17 +
 .../Universal/BdsDxe/BdsDxeExtra.uni          |   14 +
 .../MdeModulePkg/Universal/BdsDxe/BdsEntry.c  | 1202 +++++++++++++++++
 .../Universal/BdsDxe/HwErrRecSupport.c        |   42 +
 .../Universal/BdsDxe/HwErrRecSupport.h        |   26 +
 .../MdeModulePkg/Universal/BdsDxe/Language.c  |  204 +++
 .../MdeModulePkg/Universal/BdsDxe/Language.h  |   24 +
 11 files changed, 1744 insertions(+), 2 deletions(-)
 create mode 100644 Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/Bds.h
 create mode 100644 Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/BdsDxe.inf
 create mode 100644 Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/BdsDxe.uni
 create mode 100644 Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/BdsDxeExtra.uni
 create mode 100644 Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/BdsEntry.c
 create mode 100644 Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/HwErrRecSupport.c
 create mode 100644 Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/HwErrRecSupport.h
 create mode 100644 Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/Language.c
 create mode 100644 Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/Language.h

diff --git a/Platform/Intel/PurleyOpenBoardPkg/BoardTiogaPass/CoreDxeInclude.dsc b/Platform/Intel/PurleyOpenBoardPkg/BoardTiogaPass/CoreDxeInclude.dsc
index 6ddd3734dc..923854c571 100644
--- a/Platform/Intel/PurleyOpenBoardPkg/BoardTiogaPass/CoreDxeInclude.dsc
+++ b/Platform/Intel/PurleyOpenBoardPkg/BoardTiogaPass/CoreDxeInclude.dsc
@@ -47,7 +47,7 @@
 
   MdeModulePkg/Universal/MonotonicCounterRuntimeDxe/MonotonicCounterRuntimeDxe.inf
 
-  MdeModulePkg/Universal/BdsDxe/BdsDxe.inf {
+  $(PLATFORM_BOARD_PACKAGE)/Override/MdeModulePkg/Universal/BdsDxe/BdsDxe.inf {
     <LibraryClasses>
 !if gMinPlatformPkgTokenSpaceGuid.PcdSerialTerminalEnable == TRUE
       NULL|MinPlatformPkg/Library/SerialPortTerminalLib/SerialPortTerminalLib.inf
diff --git a/Platform/Intel/PurleyOpenBoardPkg/BoardTiogaPass/CoreUefiBootInclude.fdf b/Platform/Intel/PurleyOpenBoardPkg/BoardTiogaPass/CoreUefiBootInclude.fdf
index dc6e9e8bc6..704eefc463 100644
--- a/Platform/Intel/PurleyOpenBoardPkg/BoardTiogaPass/CoreUefiBootInclude.fdf
+++ b/Platform/Intel/PurleyOpenBoardPkg/BoardTiogaPass/CoreUefiBootInclude.fdf
@@ -25,7 +25,7 @@ INF  MdeModulePkg/Universal/Variable/RuntimeDxe/VariableRuntimeDxe.inf
 
 INF  MdeModulePkg/Universal/MonotonicCounterRuntimeDxe/MonotonicCounterRuntimeDxe.inf
 
-INF  MdeModulePkg/Universal/BdsDxe/BdsDxe.inf
+INF  $(PLATFORM_BOARD_PACKAGE)/Override/MdeModulePkg/Universal/BdsDxe/BdsDxe.inf
 
 !if gMinPlatformPkgTokenSpaceGuid.PcdSerialTerminalEnable == TRUE
 INF  MdeModulePkg/Universal/SerialDxe/SerialDxe.inf
diff --git a/Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/Bds.h b/Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/Bds.h
new file mode 100644
index 0000000000..9e3a13cbda
--- /dev/null
+++ b/Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/Bds.h
@@ -0,0 +1,107 @@
+/** @file
+  Head file for BDS Architectural Protocol implementation
+
+Copyright (c) 2004 - 2018, Intel Corporation. All rights reserved.<BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef _BDS_MODULE_H_
+#define _BDS_MODULE_H_
+
+#include <Uefi.h>
+#include <Guid/GlobalVariable.h>
+#include <Guid/ConnectConInEvent.h>
+#include <Guid/StatusCodeDataTypeVariable.h>
+#include <Guid/EventGroup.h>
+
+#include <Protocol/Bds.h>
+#include <Protocol/LoadedImage.h>
+#include <Protocol/DeferredImageLoad.h>
+
+#include <Library/UefiDriverEntryPoint.h>
+#include <Library/DebugLib.h>
+#include <Library/BaseMemoryLib.h>
+#include <Library/UefiBootServicesTableLib.h>
+#include <Library/UefiRuntimeServicesTableLib.h>
+#include <Library/UefiLib.h>
+#include <Library/MemoryAllocationLib.h>
+#include <Library/ReportStatusCodeLib.h>
+#include <Library/BaseLib.h>
+#include <Library/PcdLib.h>
+#include <Library/PerformanceLib.h>
+#include <Library/DevicePathLib.h>
+#include <Library/PrintLib.h>
+
+#include <Library/UefiBootManagerLib.h>
+#include <Library/PlatformBootManagerLib.h>
+
+#if !defined (EFI_REMOVABLE_MEDIA_FILE_NAME)
+  #if defined (MDE_CPU_EBC)
+//
+// Uefi specification only defines the default boot file name for IA32, X64
+// and IPF processor, so need define boot file name for EBC architecture here.
+//
+#define EFI_REMOVABLE_MEDIA_FILE_NAME  L"\\EFI\\BOOT\\BOOTEBC.EFI"
+  #else
+    #error "Can not determine the default boot file name for unknown processor type!"
+  #endif
+#endif
+
+/**
+
+  Service routine for BdsInstance->Entry(). Devices are connected, the
+  consoles are initialized, and the boot options are tried.
+
+  @param This            Protocol Instance structure.
+
+**/
+VOID
+EFIAPI
+BdsEntry (
+  IN  EFI_BDS_ARCH_PROTOCOL  *This
+  );
+
+/**
+  Set the variable and report the error through status code upon failure.
+
+  @param  VariableName           A Null-terminated string that is the name of the vendor's variable.
+                                 Each VariableName is unique for each VendorGuid. VariableName must
+                                 contain 1 or more characters. If VariableName is an empty string,
+                                 then EFI_INVALID_PARAMETER is returned.
+  @param  VendorGuid             A unique identifier for the vendor.
+  @param  Attributes             Attributes bitmask to set for the variable.
+  @param  DataSize               The size in bytes of the Data buffer. Unless the EFI_VARIABLE_APPEND_WRITE,
+                                 or EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS attribute is set, a size of zero
+                                 causes the variable to be deleted. When the EFI_VARIABLE_APPEND_WRITE attribute is
+                                 set, then a SetVariable() call with a DataSize of zero will not cause any change to
+                                 the variable value (the timestamp associated with the variable may be updated however
+                                 even if no new data value is provided,see the description of the
+                                 EFI_VARIABLE_AUTHENTICATION_2 descriptor below. In this case the DataSize will not
+                                 be zero since the EFI_VARIABLE_AUTHENTICATION_2 descriptor will be populated).
+  @param  Data                   The contents for the variable.
+
+  @retval EFI_SUCCESS            The firmware has successfully stored the variable and its data as
+                                 defined by the Attributes.
+  @retval EFI_INVALID_PARAMETER  An invalid combination of attribute bits, name, and GUID was supplied, or the
+                                 DataSize exceeds the maximum allowed.
+  @retval EFI_INVALID_PARAMETER  VariableName is an empty string.
+  @retval EFI_OUT_OF_RESOURCES   Not enough storage is available to hold the variable and its data.
+  @retval EFI_DEVICE_ERROR       The variable could not be retrieved due to a hardware error.
+  @retval EFI_WRITE_PROTECTED    The variable in question is read-only.
+  @retval EFI_WRITE_PROTECTED    The variable in question cannot be deleted.
+  @retval EFI_SECURITY_VIOLATION The variable could not be written due to EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACESS
+                                 being set, but the AuthInfo does NOT pass the validation check carried out by the firmware.
+
+  @retval EFI_NOT_FOUND          The variable trying to be updated or deleted was not found.
+**/
+EFI_STATUS
+BdsDxeSetVariableAndReportStatusCodeOnError (
+  IN CHAR16    *VariableName,
+  IN EFI_GUID  *VendorGuid,
+  IN UINT32    Attributes,
+  IN UINTN     DataSize,
+  IN VOID      *Data
+  );
+
+#endif
diff --git a/Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/BdsDxe.inf b/Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/BdsDxe.inf
new file mode 100644
index 0000000000..56f689a61b
--- /dev/null
+++ b/Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/BdsDxe.inf
@@ -0,0 +1,106 @@
+## @file
+#  BdsDxe module is core driver for BDS phase.
+#
+#  When DxeCore dispatching all DXE driver, this module will produce architecture protocol
+#  gEfiBdsArchProtocolGuid. After DxeCore finish dispatching, DxeCore will invoke Entry
+#  interface of protocol gEfiBdsArchProtocolGuid, then BDS phase is entered.
+#
+#  Copyright (c) 2008 - 2019, Intel Corporation. All rights reserved.<BR>
+#  SPDX-License-Identifier: BSD-2-Clause-Patent
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = BdsDxe
+  MODULE_UNI_FILE                = BdsDxe.uni
+  FILE_GUID                      = 6D33944A-EC75-4855-A54D-809C75241F6C
+  MODULE_TYPE                    = DXE_DRIVER
+  VERSION_STRING                 = 1.0
+  ENTRY_POINT                    = BdsInitialize
+
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32 X64 EBC
+#
+
+[Sources]
+  Language.h
+  Bds.h
+  HwErrRecSupport.c
+  HwErrRecSupport.h
+  Language.c
+  BdsEntry.c
+
+
+[Packages]
+  MdePkg/MdePkg.dec
+  MdeModulePkg/MdeModulePkg.dec
+
+[LibraryClasses]
+  DevicePathLib
+  BaseLib
+  MemoryAllocationLib
+  UefiDriverEntryPoint
+  UefiBootServicesTableLib
+  UefiRuntimeServicesTableLib
+  ReportStatusCodeLib
+  UefiLib
+  BaseMemoryLib
+  DebugLib
+  UefiBootManagerLib
+  VariablePolicyHelperLib
+  PlatformBootManagerLib
+  PcdLib
+  PrintLib
+
+[Guids]
+  gEfiGlobalVariableGuid                        ## SOMETIMES_PRODUCES ## Variable:L"BootNext" (The number of next boot option)
+                                                ## SOMETIMES_PRODUCES ## Variable:L"Boot####" (Boot option variable)
+                                                ## SOMETIMES_PRODUCES ## Variable:L"PlatformLang" (Platform supported languange in Rfc4646 format)
+                                                ## SOMETIMES_PRODUCES ## Variable:L"Lang" (Platform supported languange in Iso639 format)
+                                                ## SOMETIMES_PRODUCES ## Variable:L"Key####" (Hotkey option variable)
+                                                ## PRODUCES           ## Variable:L"HwErrRecSupport" (The level of platform supported hardware Error Record Persistence)
+                                                ## SOMETIMES_PRODUCES ## Variable:L"BootOptionSupport" (The feature supported in boot option menu, value could be: EFI_BOOT_OPTION_SUPPORT_KEY, EFI_BOOT_OPTION_SUPPORT_APP
+                                                ## SOMETIMES_PRODUCES (not PcdUefiVariableDefaultLangDeprecate) ## Variable:L"LangCodes" (Value of PcdUefiVariableDefaultLangCodes)
+                                                ## PRODUCES           ## Variable:L"PlatformLangCodes" (Value of PcdUefiVariableDefaultPlatformLangCodes)
+                                                ## PRODUCES           ## Variable:L"Timeout" (The time out value in second of showing progress bar)
+                                                ## SOMETIMES_PRODUCES ## Variable:L"BootOrder" (The boot option array)
+                                                ## SOMETIMES_PRODUCES ## Variable:L"DriverOrder" (The driver order list)
+                                                ## SOMETIMES_CONSUMES ## Variable:L"ConIn" (The device path of console in device)
+                                                ## SOMETIMES_CONSUMES ## Variable:L"ConOut" (The device path of console out device)
+                                                ## SOMETIMES_CONSUMES ## Variable:L"ErrOut" (The device path of error out device)
+  gConnectConInEventGuid                        ## SOMETIMES_CONSUMES ## Event
+  gEdkiiStatusCodeDataTypeVariableGuid          ## SOMETIMES_CONSUMES ## GUID
+  gEfiEventReadyToBootGuid                      ## CONSUMES           ## Event
+
+[Protocols]
+  gEfiBdsArchProtocolGuid                       ## PRODUCES
+  gEfiSimpleTextInputExProtocolGuid             ## CONSUMES
+  gEdkiiVariablePolicyProtocolGuid              ## SOMETIMES_CONSUMES
+  gEfiDeferredImageLoadProtocolGuid             ## CONSUMES
+
+[FeaturePcd]
+  gEfiMdePkgTokenSpaceGuid.PcdUefiVariableDefaultLangDeprecate    ## CONSUMES
+
+[Pcd]
+  gEfiMdePkgTokenSpaceGuid.PcdUefiVariableDefaultLangCodes            ## CONSUMES
+  gEfiMdePkgTokenSpaceGuid.PcdUefiVariableDefaultLang                 ## SOMETIMES_CONSUMES
+  gEfiMdePkgTokenSpaceGuid.PcdUefiVariableDefaultPlatformLangCodes    ## CONSUMES
+  gEfiMdePkgTokenSpaceGuid.PcdUefiVariableDefaultPlatformLang         ## CONSUMES
+  gEfiMdePkgTokenSpaceGuid.PcdHardwareErrorRecordLevel                ## CONSUMES
+  gEfiMdePkgTokenSpaceGuid.PcdPlatformBootTimeOut                     ## CONSUMES
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareVendor                    ## CONSUMES
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareRevision                  ## CONSUMES
+  gEfiMdeModulePkgTokenSpaceGuid.PcdConInConnectOnDemand              ## CONSUMES
+  gEfiMdeModulePkgTokenSpaceGuid.PcdErrorCodeSetVariable              ## SOMETIMES_CONSUMES
+  gEfiMdeModulePkgTokenSpaceGuid.PcdTestKeyUsed                       ## CONSUMES
+  gEfiMdeModulePkgTokenSpaceGuid.PcdCapsuleOnDiskSupport              ## CONSUMES
+  gEfiMdeModulePkgTokenSpaceGuid.PcdPlatformRecoverySupport           ## CONSUMES
+
+[Depex]
+  TRUE
+
+[UserExtensions.TianoCore."ExtraFiles"]
+  BdsDxeExtra.uni
diff --git a/Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/BdsDxe.uni b/Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/BdsDxe.uni
new file mode 100644
index 0000000000..73a5135bc4
--- /dev/null
+++ b/Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/BdsDxe.uni
@@ -0,0 +1,17 @@
+// /** @file
+// BDSDxe module is core driver for BDS phase.
+//
+// When DxeCore dispatching all DXE driver, this module will produce architecture protocol
+// gEfiBdsArchProtocolGuid. After DxeCore finish dispatching, DxeCore will invoke Entry
+// interface of protocol gEfiBdsArchProtocolGuid, then BDS phase is entered.
+//
+// Copyright (c) 2015 - 2018, Intel Corporation. All rights reserved.<BR>
+// SPDX-License-Identifier: BSD-2-Clause-Patent
+//
+// **/
+
+
+#string STR_MODULE_ABSTRACT    #language en-US "BdsDxe module is core driver for BDS phase"
+
+#string STR_MODULE_DESCRIPTION #language en-US "When DxeCore dispatching all DXE driver, this module will produce architecture protocol gEfiBdsArchProtocolGuid. After DxeCore finishes dispatching, DxeCore will invoke the Entry interface of protocol gEfiBdsArchProtocolGuid. Then BDS phase is entered."
+
diff --git a/Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/BdsDxeExtra.uni b/Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/BdsDxeExtra.uni
new file mode 100644
index 0000000000..e0cea10fc2
--- /dev/null
+++ b/Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/BdsDxeExtra.uni
@@ -0,0 +1,14 @@
+// /** @file
+// BdsDxe Localized Strings and Content
+//
+// Copyright (c) 2015 - 2018, Intel Corporation. All rights reserved.<BR>
+//
+// SPDX-License-Identifier: BSD-2-Clause-Patent
+//
+// **/
+
+#string STR_PROPERTIES_MODULE_NAME
+#language en-US
+"Boot Device Selection Core DXE Driver"
+
+
diff --git a/Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/BdsEntry.c b/Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/BdsEntry.c
new file mode 100644
index 0000000000..d252867318
--- /dev/null
+++ b/Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/BdsEntry.c
@@ -0,0 +1,1202 @@
+/** @file
+  This module produce main entry for BDS phase - BdsEntry.
+  When this module was dispatched by DxeCore, gEfiBdsArchProtocolGuid will be installed
+  which contains interface of BdsEntry.
+  After DxeCore finish DXE phase, gEfiBdsArchProtocolGuid->BdsEntry will be invoked
+  to enter BDS phase.
+
+Copyright (c) 2004 - 2019, Intel Corporation. All rights reserved.<BR>
+(C) Copyright 2016-2019 Hewlett Packard Enterprise Development LP<BR>
+(C) Copyright 2015 Hewlett-Packard Development Company, L.P.<BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#include "Bds.h"
+#include "Language.h"
+#include "HwErrRecSupport.h"
+#include <Library/VariablePolicyHelperLib.h>
+
+#define SET_BOOT_OPTION_SUPPORT_KEY_COUNT(a, c)  { \
+      (a) = ((a) & ~EFI_BOOT_OPTION_SUPPORT_COUNT) | (((c) << LowBitSet32 (EFI_BOOT_OPTION_SUPPORT_COUNT)) & EFI_BOOT_OPTION_SUPPORT_COUNT); \
+      }
+
+///
+/// BDS arch protocol instance initial value.
+///
+EFI_BDS_ARCH_PROTOCOL  gBds = {
+  BdsEntry
+};
+
+//
+// gConnectConInEvent - Event which is signaled when ConIn connection is required
+//
+EFI_EVENT  gConnectConInEvent = NULL;
+
+///
+/// The read-only variables defined in UEFI Spec.
+///
+CHAR16  *mReadOnlyVariables[] = {
+  EFI_PLATFORM_LANG_CODES_VARIABLE_NAME,
+  EFI_LANG_CODES_VARIABLE_NAME,
+  EFI_BOOT_OPTION_SUPPORT_VARIABLE_NAME,
+  EFI_HW_ERR_REC_SUPPORT_VARIABLE_NAME,
+  EFI_OS_INDICATIONS_SUPPORT_VARIABLE_NAME
+};
+
+CHAR16  *mBdsLoadOptionName[] = {
+  L"Driver",
+  L"SysPrep",
+  L"Boot",
+  L"PlatformRecovery"
+};
+
+/**
+  Event to Connect ConIn.
+
+  @param  Event                 Event whose notification function is being invoked.
+  @param  Context               Pointer to the notification function's context,
+                                which is implementation-dependent.
+
+**/
+VOID
+EFIAPI
+BdsDxeOnConnectConInCallBack (
+  IN EFI_EVENT  Event,
+  IN VOID       *Context
+  )
+{
+  EFI_STATUS  Status;
+
+  //
+  // When Osloader call ReadKeyStroke to signal this event
+  // no driver dependency is assumed existing. So use a non-dispatch version
+  //
+  Status = EfiBootManagerConnectConsoleVariable (ConIn);
+  if (EFI_ERROR (Status)) {
+    //
+    // Should not enter this case, if enter, the keyboard will not work.
+    // May need platfrom policy to connect keyboard.
+    //
+    DEBUG ((DEBUG_WARN, "[Bds] Connect ConIn failed - %r!!!\n", Status));
+  }
+}
+
+/**
+  Notify function for event group EFI_EVENT_GROUP_READY_TO_BOOT. This is used to
+  check whether there is remaining deferred load images.
+
+  @param[in]  Event   The Event that is being processed.
+  @param[in]  Context The Event Context.
+
+**/
+VOID
+EFIAPI
+CheckDeferredLoadImageOnReadyToBoot (
+  IN EFI_EVENT  Event,
+  IN VOID       *Context
+  )
+{
+  EFI_STATUS                        Status;
+  EFI_DEFERRED_IMAGE_LOAD_PROTOCOL  *DeferredImage;
+  UINTN                             HandleCount;
+  EFI_HANDLE                        *Handles;
+  UINTN                             Index;
+  UINTN                             ImageIndex;
+  EFI_DEVICE_PATH_PROTOCOL          *ImageDevicePath;
+  VOID                              *Image;
+  UINTN                             ImageSize;
+  BOOLEAN                           BootOption;
+  CHAR16                            *DevicePathStr;
+
+  //
+  // Find all the deferred image load protocols.
+  //
+  HandleCount = 0;
+  Handles     = NULL;
+  Status      = gBS->LocateHandleBuffer (
+                       ByProtocol,
+                       &gEfiDeferredImageLoadProtocolGuid,
+                       NULL,
+                       &HandleCount,
+                       &Handles
+                       );
+  if (EFI_ERROR (Status)) {
+    return;
+  }
+
+  for (Index = 0; Index < HandleCount; Index++) {
+    Status = gBS->HandleProtocol (Handles[Index], &gEfiDeferredImageLoadProtocolGuid, (VOID **)&DeferredImage);
+    if (EFI_ERROR (Status)) {
+      continue;
+    }
+
+    for (ImageIndex = 0; ; ImageIndex++) {
+      //
+      // Load all the deferred images in this protocol instance.
+      //
+      Status = DeferredImage->GetImageInfo (
+                                DeferredImage,
+                                ImageIndex,
+                                &ImageDevicePath,
+                                (VOID **)&Image,
+                                &ImageSize,
+                                &BootOption
+                                );
+      if (EFI_ERROR (Status)) {
+        break;
+      }
+
+      DevicePathStr = ConvertDevicePathToText (ImageDevicePath, FALSE, FALSE);
+      DEBUG ((DEBUG_LOAD, "[Bds] Image was deferred but not loaded: %s.\n", DevicePathStr));
+      if (DevicePathStr != NULL) {
+        FreePool (DevicePathStr);
+      }
+    }
+  }
+
+  if (Handles != NULL) {
+    FreePool (Handles);
+  }
+}
+
+/**
+
+  Install Boot Device Selection Protocol
+
+  @param ImageHandle     The image handle.
+  @param SystemTable     The system table.
+
+  @retval  EFI_SUCEESS  BDS has finished initializing.
+                        Return the dispatcher and recall BDS.Entry
+  @retval  Other        Return status from AllocatePool() or gBS->InstallProtocolInterface
+
+**/
+EFI_STATUS
+EFIAPI
+BdsInitialize (
+  IN EFI_HANDLE        ImageHandle,
+  IN EFI_SYSTEM_TABLE  *SystemTable
+  )
+{
+  EFI_STATUS  Status;
+  EFI_HANDLE  Handle;
+
+  //
+  // Install protocol interface
+  //
+  Handle = NULL;
+  Status = gBS->InstallMultipleProtocolInterfaces (
+                  &Handle,
+                  &gEfiBdsArchProtocolGuid,
+                  &gBds,
+                  NULL
+                  );
+  ASSERT_EFI_ERROR (Status);
+
+  DEBUG_CODE (
+    EFI_EVENT   Event;
+    //
+    // Register notify function to check deferred images on ReadyToBoot Event.
+    //
+    Status = gBS->CreateEventEx (
+                    EVT_NOTIFY_SIGNAL,
+                    TPL_CALLBACK,
+                    CheckDeferredLoadImageOnReadyToBoot,
+                    NULL,
+                    &gEfiEventReadyToBootGuid,
+                    &Event
+                    );
+    ASSERT_EFI_ERROR (Status);
+    );
+  return Status;
+}
+
+/**
+  Function waits for a given event to fire, or for an optional timeout to expire.
+
+  @param   Event              The event to wait for
+  @param   Timeout            An optional timeout value in 100 ns units.
+
+  @retval  EFI_SUCCESS      Event fired before Timeout expired.
+  @retval  EFI_TIME_OUT     Timout expired before Event fired..
+
+**/
+EFI_STATUS
+BdsWaitForSingleEvent (
+  IN  EFI_EVENT  Event,
+  IN  UINT64     Timeout       OPTIONAL
+  )
+{
+  UINTN       Index;
+  EFI_STATUS  Status;
+  EFI_EVENT   TimerEvent;
+  EFI_EVENT   WaitList[2];
+
+  if (Timeout != 0) {
+    //
+    // Create a timer event
+    //
+    Status = gBS->CreateEvent (EVT_TIMER, 0, NULL, NULL, &TimerEvent);
+    if (!EFI_ERROR (Status)) {
+      //
+      // Set the timer event
+      //
+      gBS->SetTimer (
+             TimerEvent,
+             TimerRelative,
+             Timeout
+             );
+
+      //
+      // Wait for the original event or the timer
+      //
+      WaitList[0] = Event;
+      WaitList[1] = TimerEvent;
+      Status      = gBS->WaitForEvent (2, WaitList, &Index);
+      ASSERT_EFI_ERROR (Status);
+      gBS->CloseEvent (TimerEvent);
+
+      //
+      // If the timer expired, change the return to timed out
+      //
+      if (Index == 1) {
+        Status = EFI_TIMEOUT;
+      }
+    }
+  } else {
+    //
+    // No timeout... just wait on the event
+    //
+    Status = gBS->WaitForEvent (1, &Event, &Index);
+    ASSERT (!EFI_ERROR (Status));
+    ASSERT (Index == 0);
+  }
+
+  return Status;
+}
+
+/**
+  The function reads user inputs.
+
+**/
+VOID
+BdsReadKeys (
+  VOID
+  )
+{
+  EFI_STATUS     Status;
+  EFI_INPUT_KEY  Key;
+
+  if (PcdGetBool (PcdConInConnectOnDemand)) {
+    return;
+  }
+
+  while (gST->ConIn != NULL) {
+    Status = gST->ConIn->ReadKeyStroke (gST->ConIn, &Key);
+
+    if (EFI_ERROR (Status)) {
+      //
+      // No more keys.
+      //
+      break;
+    }
+  }
+}
+
+/**
+  The function waits for the boot manager timeout expires or hotkey is pressed.
+
+  It calls PlatformBootManagerWaitCallback each second.
+
+  @param     HotkeyTriggered   Input hotkey event.
+**/
+VOID
+BdsWait (
+  IN EFI_EVENT  HotkeyTriggered
+  )
+{
+  EFI_STATUS  Status;
+  UINT16      TimeoutRemain;
+
+  DEBUG ((DEBUG_INFO, "[Bds]BdsWait ...Zzzzzzzzzzzz...\n"));
+
+  TimeoutRemain = PcdGet16 (PcdPlatformBootTimeOut);
+  while (TimeoutRemain != 0) {
+    DEBUG ((DEBUG_INFO, "[Bds]BdsWait(%d)..Zzzz...\n", (UINTN)TimeoutRemain));
+    PlatformBootManagerWaitCallback (TimeoutRemain);
+
+    BdsReadKeys (); // BUGBUG: Only reading can signal HotkeyTriggered
+                    //         Can be removed after all keyboard drivers invoke callback in timer callback.
+
+    if (HotkeyTriggered != NULL) {
+      Status = BdsWaitForSingleEvent (HotkeyTriggered, EFI_TIMER_PERIOD_SECONDS (1));
+      if (!EFI_ERROR (Status)) {
+        break;
+      }
+    } else {
+      gBS->Stall (1000000);
+    }
+
+    //
+    // 0xffff means waiting forever
+    // BDS with no hotkey provided and 0xffff as timeout will "hang" in the loop
+    //
+    if (TimeoutRemain != 0xffff) {
+      TimeoutRemain--;
+    }
+  }
+
+  //
+  // If the platform configured a nonzero and finite time-out, and we have
+  // actually reached that, report 100% completion to the platform.
+  //
+  // Note that the (TimeoutRemain == 0) condition excludes
+  // PcdPlatformBootTimeOut=0xFFFF, and that's deliberate.
+  //
+  if ((PcdGet16 (PcdPlatformBootTimeOut) != 0) && (TimeoutRemain == 0)) {
+    PlatformBootManagerWaitCallback (0);
+  }
+
+  DEBUG ((DEBUG_INFO, "[Bds]Exit the waiting!\n"));
+}
+
+/**
+  Attempt to boot each boot option in the BootOptions array.
+
+  @param BootOptions       Input boot option array.
+  @param BootOptionCount   Input boot option count.
+  @param BootManagerMenu   Input boot manager menu.
+
+  @retval TRUE  Successfully boot one of the boot options.
+  @retval FALSE Failed boot any of the boot options.
+**/
+BOOLEAN
+BootBootOptions (
+  IN EFI_BOOT_MANAGER_LOAD_OPTION  *BootOptions,
+  IN UINTN                         BootOptionCount,
+  IN EFI_BOOT_MANAGER_LOAD_OPTION  *BootManagerMenu OPTIONAL
+  )
+{
+  UINTN  Index;
+
+  //
+  // Report Status Code to indicate BDS starts attempting booting from the UEFI BootOrder list.
+  //
+  REPORT_STATUS_CODE (EFI_PROGRESS_CODE, (EFI_SOFTWARE_DXE_BS_DRIVER | EFI_SW_DXE_BS_PC_ATTEMPT_BOOT_ORDER_EVENT));
+
+  //
+  // Attempt boot each boot option
+  //
+  for (Index = 0; Index < BootOptionCount; Index++) {
+    //
+    // According to EFI Specification, if a load option is not marked
+    // as LOAD_OPTION_ACTIVE, the boot manager will not automatically
+    // load the option.
+    //
+    if ((BootOptions[Index].Attributes & LOAD_OPTION_ACTIVE) == 0) {
+      continue;
+    }
+
+    //
+    // Boot#### load options with LOAD_OPTION_CATEGORY_APP are executables which are not
+    // part of the normal boot processing. Boot options with reserved category values will be
+    // ignored by the boot manager.
+    //
+    if ((BootOptions[Index].Attributes & LOAD_OPTION_CATEGORY) != LOAD_OPTION_CATEGORY_BOOT) {
+      continue;
+    }
+
+    //
+    // All the driver options should have been processed since
+    // now boot will be performed.
+    //
+    EfiBootManagerBoot (&BootOptions[Index]);
+
+    //
+    // If the boot via Boot#### returns with a status of EFI_SUCCESS, platform firmware
+    // supports boot manager menu, and if firmware is configured to boot in an
+    // interactive mode, the boot manager will stop processing the BootOrder variable and
+    // present a boot manager menu to the user.
+    //
+    if ((BootManagerMenu != NULL) && (BootOptions[Index].Status == EFI_SUCCESS)) {
+      EfiBootManagerBoot (BootManagerMenu);
+      break;
+    }
+  }
+
+  return (BOOLEAN)(Index < BootOptionCount);
+}
+
+/**
+  The function will load and start every Driver####, SysPrep#### or PlatformRecovery####.
+
+  @param  LoadOptions        Load option array.
+  @param  LoadOptionCount    Load option count.
+**/
+VOID
+ProcessLoadOptions (
+  IN EFI_BOOT_MANAGER_LOAD_OPTION  *LoadOptions,
+  IN UINTN                         LoadOptionCount
+  )
+{
+  EFI_STATUS                         Status;
+  UINTN                              Index;
+  BOOLEAN                            ReconnectAll;
+  EFI_BOOT_MANAGER_LOAD_OPTION_TYPE  LoadOptionType;
+
+  ReconnectAll   = FALSE;
+  LoadOptionType = LoadOptionTypeMax;
+
+  //
+  // Process the driver option
+  //
+  for (Index = 0; Index < LoadOptionCount; Index++) {
+    //
+    // All the load options in the array should be of the same type.
+    //
+    if (Index == 0) {
+      LoadOptionType = LoadOptions[Index].OptionType;
+    }
+
+    ASSERT (LoadOptionType == LoadOptions[Index].OptionType);
+    ASSERT (LoadOptionType != LoadOptionTypeBoot);
+
+    Status = EfiBootManagerProcessLoadOption (&LoadOptions[Index]);
+
+    //
+    // Status indicates whether the load option is loaded and executed
+    // LoadOptions[Index].Status is what the load option returns
+    //
+    if (!EFI_ERROR (Status)) {
+      //
+      // Stop processing if any PlatformRecovery#### returns success.
+      //
+      if ((LoadOptions[Index].Status == EFI_SUCCESS) &&
+          (LoadOptionType == LoadOptionTypePlatformRecovery))
+      {
+        break;
+      }
+
+      //
+      // Only set ReconnectAll flag when the load option executes successfully.
+      //
+      if (!EFI_ERROR (LoadOptions[Index].Status) &&
+          ((LoadOptions[Index].Attributes & LOAD_OPTION_FORCE_RECONNECT) != 0))
+      {
+        ReconnectAll = TRUE;
+      }
+    }
+  }
+
+  //
+  // If a driver load option is marked as LOAD_OPTION_FORCE_RECONNECT,
+  // then all of the EFI drivers in the system will be disconnected and
+  // reconnected after the last driver load option is processed.
+  //
+  if (ReconnectAll && (LoadOptionType == LoadOptionTypeDriver)) {
+    EfiBootManagerDisconnectAll ();
+    EfiBootManagerConnectAll ();
+  }
+}
+
+/**
+
+  Validate input console variable data.
+
+  If found the device path is not a valid device path, remove the variable.
+
+  @param VariableName             Input console variable name.
+
+**/
+VOID
+BdsFormalizeConsoleVariable (
+  IN  CHAR16  *VariableName
+  )
+{
+  EFI_DEVICE_PATH_PROTOCOL  *DevicePath;
+  UINTN                     VariableSize;
+  EFI_STATUS                Status;
+
+  GetEfiGlobalVariable2 (VariableName, (VOID **)&DevicePath, &VariableSize);
+  if ((DevicePath != NULL) && !IsDevicePathValid (DevicePath, VariableSize)) {
+    Status = gRT->SetVariable (
+                    VariableName,
+                    &gEfiGlobalVariableGuid,
+                    EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS | EFI_VARIABLE_NON_VOLATILE,
+                    0,
+                    NULL
+                    );
+    //
+    // Deleting variable with current variable implementation shouldn't fail.
+    //
+    ASSERT_EFI_ERROR (Status);
+  }
+
+  if (DevicePath != NULL) {
+    FreePool (DevicePath);
+  }
+}
+
+/**
+  Formalize OsIndication related variables.
+
+  For OsIndicationsSupported, Create a BS/RT/UINT64 variable to report caps
+  Delete OsIndications variable if it is not NV/BS/RT UINT64.
+
+  Item 3 is used to solve case when OS corrupts OsIndications. Here simply delete this NV variable.
+
+  Create a boot option for BootManagerMenu if it hasn't been created yet
+
+**/
+VOID
+BdsFormalizeOSIndicationVariable (
+  VOID
+  )
+{
+  EFI_STATUS                    Status;
+  UINT64                        OsIndicationSupport;
+  UINT64                        OsIndication;
+  UINTN                         DataSize;
+  UINT32                        Attributes;
+  EFI_BOOT_MANAGER_LOAD_OPTION  BootManagerMenu;
+
+  //
+  // OS indicater support variable
+  //
+  Status = EfiBootManagerGetBootManagerMenu (&BootManagerMenu);
+  if (Status != EFI_NOT_FOUND) {
+    OsIndicationSupport = EFI_OS_INDICATIONS_BOOT_TO_FW_UI;
+    EfiBootManagerFreeLoadOption (&BootManagerMenu);
+  } else {
+    OsIndicationSupport = 0;
+  }
+
+  if (PcdGetBool (PcdPlatformRecoverySupport)) {
+    OsIndicationSupport |= EFI_OS_INDICATIONS_START_PLATFORM_RECOVERY;
+  }
+
+  if (PcdGetBool (PcdCapsuleOnDiskSupport)) {
+    OsIndicationSupport |= EFI_OS_INDICATIONS_FILE_CAPSULE_DELIVERY_SUPPORTED;
+  }
+
+  Status = gRT->SetVariable (
+                  EFI_OS_INDICATIONS_SUPPORT_VARIABLE_NAME,
+                  &gEfiGlobalVariableGuid,
+                  EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS,
+                  sizeof (UINT64),
+                  &OsIndicationSupport
+                  );
+  //
+  // Platform needs to make sure setting volatile variable before calling 3rd party code shouldn't fail.
+  //
+  ASSERT_EFI_ERROR (Status);
+
+  //
+  // If OsIndications is invalid, remove it.
+  // Invalid case
+  //   1. Data size != UINT64
+  //   2. OsIndication value inconsistence
+  //   3. OsIndication attribute inconsistence
+  //
+  OsIndication = 0;
+  Attributes   = 0;
+  DataSize     = sizeof (UINT64);
+  Status       = gRT->GetVariable (
+                        EFI_OS_INDICATIONS_VARIABLE_NAME,
+                        &gEfiGlobalVariableGuid,
+                        &Attributes,
+                        &DataSize,
+                        &OsIndication
+                        );
+  if (Status == EFI_NOT_FOUND) {
+    return;
+  }
+
+  if ((DataSize != sizeof (OsIndication)) ||
+      ((OsIndication & ~OsIndicationSupport) != 0) ||
+      (Attributes != (EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS | EFI_VARIABLE_NON_VOLATILE))
+      )
+  {
+    DEBUG ((DEBUG_ERROR, "[Bds] Unformalized OsIndications variable exists. Delete it\n"));
+    Status = gRT->SetVariable (
+                    EFI_OS_INDICATIONS_VARIABLE_NAME,
+                    &gEfiGlobalVariableGuid,
+                    0,
+                    0,
+                    NULL
+                    );
+    //
+    // Deleting variable with current variable implementation shouldn't fail.
+    //
+    ASSERT_EFI_ERROR (Status);
+  }
+}
+
+/**
+
+  Validate variables.
+
+**/
+VOID
+BdsFormalizeEfiGlobalVariable (
+  VOID
+  )
+{
+  //
+  // Validate Console variable.
+  //
+  BdsFormalizeConsoleVariable (EFI_CON_IN_VARIABLE_NAME);
+  BdsFormalizeConsoleVariable (EFI_CON_OUT_VARIABLE_NAME);
+  BdsFormalizeConsoleVariable (EFI_ERR_OUT_VARIABLE_NAME);
+
+  //
+  // Validate OSIndication related variable.
+  //
+  BdsFormalizeOSIndicationVariable ();
+}
+
+/**
+
+  Service routine for BdsInstance->Entry(). Devices are connected, the
+  consoles are initialized, and the boot options are tried.
+
+  @param This             Protocol Instance structure.
+
+**/
+VOID
+EFIAPI
+BdsEntry (
+  IN EFI_BDS_ARCH_PROTOCOL  *This
+  )
+{
+  EFI_BOOT_MANAGER_LOAD_OPTION    *LoadOptions;
+  UINTN                           LoadOptionCount;
+  CHAR16                          *FirmwareVendor;
+  EFI_EVENT                       HotkeyTriggered;
+  UINT64                          OsIndication;
+  UINTN                           DataSize;
+  EFI_STATUS                      Status;
+  UINT32                          BootOptionSupport;
+  UINT16                          BootTimeOut;
+  EDKII_VARIABLE_POLICY_PROTOCOL  *VariablePolicy;
+  UINTN                           Index;
+  EFI_BOOT_MANAGER_LOAD_OPTION    LoadOption;
+  UINT16                          *BootNext;
+  CHAR16                          BootNextVariableName[sizeof ("Boot####")];
+  EFI_BOOT_MANAGER_LOAD_OPTION    BootManagerMenu;
+  BOOLEAN                         BootFwUi;
+  BOOLEAN                         PlatformRecovery;
+  BOOLEAN                         BootSuccess;
+  EFI_DEVICE_PATH_PROTOCOL        *FilePath;
+  EFI_STATUS                      BootManagerMenuStatus;
+  EFI_BOOT_MANAGER_LOAD_OPTION    PlatformDefaultBootOption;
+
+  HotkeyTriggered = NULL;
+  Status          = EFI_SUCCESS;
+  BootSuccess     = FALSE;
+
+  //
+  // Insert the performance probe
+  //
+  PERF_CROSSMODULE_END ("DXE");
+  PERF_CROSSMODULE_BEGIN ("BDS");
+  DEBUG ((DEBUG_INFO, "[Bds] Entry...\n"));
+
+  //
+  // Fill in FirmwareVendor and FirmwareRevision from PCDs
+  //
+  FirmwareVendor      = (CHAR16 *)PcdGetPtr (PcdFirmwareVendor);
+  gST->FirmwareVendor = AllocateRuntimeCopyPool (StrSize (FirmwareVendor), FirmwareVendor);
+  ASSERT (gST->FirmwareVendor != NULL);
+  gST->FirmwareRevision = PcdGet32 (PcdFirmwareRevision);
+
+  //
+  // Fixup Tasble CRC after we updated Firmware Vendor and Revision
+  //
+  gST->Hdr.CRC32 = 0;
+  gBS->CalculateCrc32 ((VOID *)gST, sizeof (EFI_SYSTEM_TABLE), &gST->Hdr.CRC32);
+
+  //
+  // Validate Variable.
+  //
+  BdsFormalizeEfiGlobalVariable ();
+
+  //
+  // Mark the read-only variables if the Variable Lock protocol exists
+  //
+  Status = gBS->LocateProtocol (&gEdkiiVariablePolicyProtocolGuid, NULL, (VOID **)&VariablePolicy);
+  DEBUG ((DEBUG_INFO, "[BdsDxe] Locate Variable Policy protocol - %r\n", Status));
+  if (!EFI_ERROR (Status)) {
+    for (Index = 0; Index < ARRAY_SIZE (mReadOnlyVariables); Index++) {
+      Status = RegisterBasicVariablePolicy (
+                 VariablePolicy,
+                 &gEfiGlobalVariableGuid,
+                 mReadOnlyVariables[Index],
+                 VARIABLE_POLICY_NO_MIN_SIZE,
+                 VARIABLE_POLICY_NO_MAX_SIZE,
+                 VARIABLE_POLICY_NO_MUST_ATTR,
+                 VARIABLE_POLICY_NO_CANT_ATTR,
+                 VARIABLE_POLICY_TYPE_LOCK_NOW
+                 );
+      ASSERT_EFI_ERROR (Status);
+    }
+  }
+
+  InitializeHwErrRecSupport ();
+
+  //
+  // Initialize L"Timeout" EFI global variable.
+  //
+  BootTimeOut = PcdGet16 (PcdPlatformBootTimeOut);
+  if (BootTimeOut != 0xFFFF) {
+    //
+    // If time out value equal 0xFFFF, no need set to 0xFFFF to variable area because UEFI specification
+    // define same behavior between no value or 0xFFFF value for L"Timeout".
+    //
+    BdsDxeSetVariableAndReportStatusCodeOnError (
+      EFI_TIME_OUT_VARIABLE_NAME,
+      &gEfiGlobalVariableGuid,
+      EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS | EFI_VARIABLE_NON_VOLATILE,
+      sizeof (UINT16),
+      &BootTimeOut
+      );
+  }
+
+  //
+  // Initialize L"BootOptionSupport" EFI global variable.
+  // Lazy-ConIn implictly disables BDS hotkey.
+  //
+  BootOptionSupport = EFI_BOOT_OPTION_SUPPORT_APP | EFI_BOOT_OPTION_SUPPORT_SYSPREP;
+  if (!PcdGetBool (PcdConInConnectOnDemand)) {
+    BootOptionSupport |= EFI_BOOT_OPTION_SUPPORT_KEY;
+    SET_BOOT_OPTION_SUPPORT_KEY_COUNT (BootOptionSupport, 3);
+  }
+
+  Status = gRT->SetVariable (
+                  EFI_BOOT_OPTION_SUPPORT_VARIABLE_NAME,
+                  &gEfiGlobalVariableGuid,
+                  EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS,
+                  sizeof (BootOptionSupport),
+                  &BootOptionSupport
+                  );
+  //
+  // Platform needs to make sure setting volatile variable before calling 3rd party code shouldn't fail.
+  //
+  ASSERT_EFI_ERROR (Status);
+
+  //
+  // Cache the "BootNext" NV variable before calling any PlatformBootManagerLib APIs
+  // This could avoid the "BootNext" set by PlatformBootManagerLib be consumed in this boot.
+  //
+  GetEfiGlobalVariable2 (EFI_BOOT_NEXT_VARIABLE_NAME, (VOID **)&BootNext, &DataSize);
+  if (DataSize != sizeof (UINT16)) {
+    if (BootNext != NULL) {
+      FreePool (BootNext);
+    }
+
+    BootNext = NULL;
+  }
+
+  //
+  // Initialize the platform language variables
+  //
+  InitializeLanguage (TRUE);
+
+  FilePath = FileDevicePath (NULL, EFI_REMOVABLE_MEDIA_FILE_NAME);
+  if (FilePath == NULL) {
+    DEBUG ((DEBUG_ERROR, "Fail to allocate memory for default boot file path. Unable to boot.\n"));
+    CpuDeadLoop ();
+  }
+
+  Status = EfiBootManagerInitializeLoadOption (
+             &PlatformDefaultBootOption,
+             LoadOptionNumberUnassigned,
+             LoadOptionTypePlatformRecovery,
+             LOAD_OPTION_ACTIVE,
+             L"Default PlatformRecovery",
+             FilePath,
+             NULL,
+             0
+             );
+  ASSERT_EFI_ERROR (Status);
+
+  //
+  // System firmware must include a PlatformRecovery#### variable specifying
+  // a short-form File Path Media Device Path containing the platform default
+  // file path for removable media if the platform supports Platform Recovery.
+  //
+  if (PcdGetBool (PcdPlatformRecoverySupport)) {
+    LoadOptions = EfiBootManagerGetLoadOptions (&LoadOptionCount, LoadOptionTypePlatformRecovery);
+    if (EfiBootManagerFindLoadOption (&PlatformDefaultBootOption, LoadOptions, LoadOptionCount) == -1) {
+      for (Index = 0; Index < LoadOptionCount; Index++) {
+        //
+        // The PlatformRecovery#### options are sorted by OptionNumber.
+        // Find the the smallest unused number as the new OptionNumber.
+        //
+        if (LoadOptions[Index].OptionNumber != Index) {
+          break;
+        }
+      }
+
+      PlatformDefaultBootOption.OptionNumber = Index;
+      Status                                 = EfiBootManagerLoadOptionToVariable (&PlatformDefaultBootOption);
+      ASSERT_EFI_ERROR (Status);
+    }
+
+    EfiBootManagerFreeLoadOptions (LoadOptions, LoadOptionCount);
+  }
+
+  FreePool (FilePath);
+
+  //
+  // Report Status Code to indicate connecting drivers will happen
+  //
+  REPORT_STATUS_CODE (
+    EFI_PROGRESS_CODE,
+    (EFI_SOFTWARE_DXE_BS_DRIVER | EFI_SW_DXE_BS_PC_BEGIN_CONNECTING_DRIVERS)
+    );
+
+  //
+  // Initialize ConnectConIn event before calling platform code.
+  //
+  if (PcdGetBool (PcdConInConnectOnDemand)) {
+    Status = gBS->CreateEventEx (
+                    EVT_NOTIFY_SIGNAL,
+                    TPL_CALLBACK,
+                    BdsDxeOnConnectConInCallBack,
+                    NULL,
+                    &gConnectConInEventGuid,
+                    &gConnectConInEvent
+                    );
+    if (EFI_ERROR (Status)) {
+      gConnectConInEvent = NULL;
+    }
+  }
+
+  //
+  // Do the platform init, can be customized by OEM/IBV
+  // Possible things that can be done in PlatformBootManagerBeforeConsole:
+  // > Update console variable: 1. include hot-plug devices; 2. Clear ConIn and add SOL for AMT
+  // > Register new Driver#### or Boot####
+  // > Register new Key####: e.g.: F12
+  // > Signal ReadyToLock event
+  // > Authentication action: 1. connect Auth devices; 2. Identify auto logon user.
+  //
+  PERF_INMODULE_BEGIN ("PlatformBootManagerBeforeConsole");
+  PlatformBootManagerBeforeConsole ();
+  PERF_INMODULE_END ("PlatformBootManagerBeforeConsole");
+
+  //
+  // Initialize hotkey service
+  //
+  EfiBootManagerStartHotkeyService (&HotkeyTriggered);
+
+  //
+  // Execute Driver Options
+  //
+  LoadOptions = EfiBootManagerGetLoadOptions (&LoadOptionCount, LoadOptionTypeDriver);
+  ProcessLoadOptions (LoadOptions, LoadOptionCount);
+  EfiBootManagerFreeLoadOptions (LoadOptions, LoadOptionCount);
+
+  //
+  // Connect consoles
+  //
+  PERF_INMODULE_BEGIN ("EfiBootManagerConnectAllDefaultConsoles");
+  if (PcdGetBool (PcdConInConnectOnDemand)) {
+    EfiBootManagerConnectConsoleVariable (ConOut);
+    EfiBootManagerConnectConsoleVariable (ErrOut);
+    //
+    // Do not connect ConIn devices when lazy ConIn feature is ON.
+    //
+  } else {
+    EfiBootManagerConnectAllDefaultConsoles ();
+  }
+
+  PERF_INMODULE_END ("EfiBootManagerConnectAllDefaultConsoles");
+
+  //
+  // Do the platform specific action after the console is ready
+  // Possible things that can be done in PlatformBootManagerAfterConsole:
+  // > Console post action:
+  //   > Dynamically switch output mode from 100x31 to 80x25 for certain senarino
+  //   > Signal console ready platform customized event
+  // > Run diagnostics like memory testing
+  // > Connect certain devices
+  // > Dispatch aditional option roms
+  // > Special boot: e.g.: USB boot, enter UI
+  //
+  PERF_INMODULE_BEGIN ("PlatformBootManagerAfterConsole");
+  PlatformBootManagerAfterConsole ();
+  PERF_INMODULE_END ("PlatformBootManagerAfterConsole");
+
+  //
+  // If any component set PcdTestKeyUsed to TRUE because use of a test key
+  // was detected, then display a warning message on the debug log and the console
+  //
+  if (PcdGetBool (PcdTestKeyUsed)) {
+    DEBUG ((DEBUG_ERROR, "**********************************\n"));
+    DEBUG ((DEBUG_ERROR, "**  WARNING: Test Key is used.  **\n"));
+    DEBUG ((DEBUG_ERROR, "**********************************\n"));
+    Print (L"**  WARNING: Test Key is used.  **\n");
+  }
+
+  //
+  // Boot to Boot Manager Menu when EFI_OS_INDICATIONS_BOOT_TO_FW_UI is set. Skip HotkeyBoot
+  //
+  DataSize = sizeof (UINT64);
+  Status   = gRT->GetVariable (
+                    EFI_OS_INDICATIONS_VARIABLE_NAME,
+                    &gEfiGlobalVariableGuid,
+                    NULL,
+                    &DataSize,
+                    &OsIndication
+                    );
+  if (EFI_ERROR (Status)) {
+    OsIndication = 0;
+  }
+
+  DEBUG_CODE_BEGIN ();
+  EFI_BOOT_MANAGER_LOAD_OPTION_TYPE  LoadOptionType;
+
+  DEBUG ((DEBUG_INFO, "[Bds]OsIndication: %016x\n", OsIndication));
+  DEBUG ((DEBUG_INFO, "[Bds]=============Begin Load Options Dumping ...=============\n"));
+  for (LoadOptionType = 0; LoadOptionType < LoadOptionTypeMax; LoadOptionType++) {
+    DEBUG ((
+      DEBUG_INFO,
+      "  %s Options:\n",
+      mBdsLoadOptionName[LoadOptionType]
+      ));
+    LoadOptions = EfiBootManagerGetLoadOptions (&LoadOptionCount, LoadOptionType);
+    for (Index = 0; Index < LoadOptionCount; Index++) {
+      DEBUG ((
+        DEBUG_INFO,
+        "    %s%04x: %s \t\t 0x%04x\n",
+        mBdsLoadOptionName[LoadOptionType],
+        LoadOptions[Index].OptionNumber,
+        LoadOptions[Index].Description,
+        LoadOptions[Index].Attributes
+        ));
+    }
+
+    EfiBootManagerFreeLoadOptions (LoadOptions, LoadOptionCount);
+  }
+
+  DEBUG ((DEBUG_INFO, "[Bds]=============End Load Options Dumping=============\n"));
+  DEBUG_CODE_END ();
+
+  //
+  // BootManagerMenu doesn't contain the correct information when return status is EFI_NOT_FOUND.
+  //
+  BootManagerMenuStatus = EfiBootManagerGetBootManagerMenu (&BootManagerMenu);
+
+  BootFwUi         = (BOOLEAN)((OsIndication & EFI_OS_INDICATIONS_BOOT_TO_FW_UI) != 0);
+  PlatformRecovery = (BOOLEAN)((OsIndication & EFI_OS_INDICATIONS_START_PLATFORM_RECOVERY) != 0);
+  //
+  // Clear EFI_OS_INDICATIONS_BOOT_TO_FW_UI to acknowledge OS
+  //
+  if (BootFwUi || PlatformRecovery) {
+    OsIndication &= ~((UINT64)(EFI_OS_INDICATIONS_BOOT_TO_FW_UI | EFI_OS_INDICATIONS_START_PLATFORM_RECOVERY));
+    Status        = gRT->SetVariable (
+                           EFI_OS_INDICATIONS_VARIABLE_NAME,
+                           &gEfiGlobalVariableGuid,
+                           EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS | EFI_VARIABLE_NON_VOLATILE,
+                           sizeof (UINT64),
+                           &OsIndication
+                           );
+    //
+    // Changing the content without increasing its size with current variable implementation shouldn't fail.
+    //
+    ASSERT_EFI_ERROR (Status);
+  }
+
+  //
+  // Launch Boot Manager Menu directly when EFI_OS_INDICATIONS_BOOT_TO_FW_UI is set. Skip HotkeyBoot
+  //
+  if (BootFwUi && (BootManagerMenuStatus != EFI_NOT_FOUND)) {
+    //
+    // Follow generic rule, Call BdsDxeOnConnectConInCallBack to connect ConIn before enter UI
+    //
+    if (PcdGetBool (PcdConInConnectOnDemand)) {
+      BdsDxeOnConnectConInCallBack (NULL, NULL);
+    }
+
+    //
+    // Directly enter the setup page.
+    //
+    EfiBootManagerBoot (&BootManagerMenu);
+  }
+
+  if (!PlatformRecovery) {
+    //
+    // Execute SysPrep####
+    //
+    LoadOptions = EfiBootManagerGetLoadOptions (&LoadOptionCount, LoadOptionTypeSysPrep);
+    ProcessLoadOptions (LoadOptions, LoadOptionCount);
+    EfiBootManagerFreeLoadOptions (LoadOptions, LoadOptionCount);
+
+    //
+    // Execute Key####
+    //
+    PERF_INMODULE_BEGIN ("BdsWait");
+    BdsWait (HotkeyTriggered);
+    PERF_INMODULE_END ("BdsWait");
+    //
+    // BdsReadKeys() can be removed after all keyboard drivers invoke callback in timer callback.
+    //
+    BdsReadKeys ();
+
+    EfiBootManagerHotkeyBoot ();
+
+    if (BootNext != NULL) {
+      //
+      // Delete "BootNext" NV variable before transferring control to it to prevent loops.
+      //
+      Status = gRT->SetVariable (
+                      EFI_BOOT_NEXT_VARIABLE_NAME,
+                      &gEfiGlobalVariableGuid,
+                      0,
+                      0,
+                      NULL
+                      );
+      //
+      // Deleting NV variable shouldn't fail unless it doesn't exist.
+      //
+      ASSERT (Status == EFI_SUCCESS || Status == EFI_NOT_FOUND);
+
+      //
+      // Boot to "BootNext"
+      //
+      UnicodeSPrint (BootNextVariableName, sizeof (BootNextVariableName), L"Boot%04x", *BootNext);
+      Status = EfiBootManagerVariableToLoadOption (BootNextVariableName, &LoadOption);
+      if (!EFI_ERROR (Status)) {
+        EfiBootManagerBoot (&LoadOption);
+        EfiBootManagerFreeLoadOption (&LoadOption);
+        if ((LoadOption.Status == EFI_SUCCESS) &&
+            (BootManagerMenuStatus != EFI_NOT_FOUND) &&
+            (LoadOption.OptionNumber != BootManagerMenu.OptionNumber))
+        {
+          //
+          // Boot to Boot Manager Menu upon EFI_SUCCESS
+          // Exception: Do not boot again when the BootNext points to Boot Manager Menu.
+          //
+          EfiBootManagerBoot (&BootManagerMenu);
+        }
+      }
+    }
+
+    do {
+      //
+      // Retry to boot if any of the boot succeeds
+      //
+      LoadOptions = EfiBootManagerGetLoadOptions (&LoadOptionCount, LoadOptionTypeBoot);
+      BootSuccess = BootBootOptions (LoadOptions, LoadOptionCount, (BootManagerMenuStatus != EFI_NOT_FOUND) ? &BootManagerMenu : NULL);
+      EfiBootManagerFreeLoadOptions (LoadOptions, LoadOptionCount);
+    } while (BootSuccess);
+  }
+
+  if (BootManagerMenuStatus != EFI_NOT_FOUND) {
+    EfiBootManagerFreeLoadOption (&BootManagerMenu);
+  }
+
+  if (!BootSuccess) {
+    if (PcdGetBool (PcdPlatformRecoverySupport)) {
+      LoadOptions = EfiBootManagerGetLoadOptions (&LoadOptionCount, LoadOptionTypePlatformRecovery);
+      ProcessLoadOptions (LoadOptions, LoadOptionCount);
+      EfiBootManagerFreeLoadOptions (LoadOptions, LoadOptionCount);
+    } else {
+      //
+      // When platform recovery is not enabled, still boot to platform default file path.
+      //
+      EfiBootManagerProcessLoadOption (&PlatformDefaultBootOption);
+    }
+  }
+
+  EfiBootManagerFreeLoadOption (&PlatformDefaultBootOption);
+
+  DEBUG ((DEBUG_ERROR, "[Bds] Unable to boot!\n"));
+  PlatformBootManagerUnableToBoot ();
+  CpuDeadLoop ();
+}
+
+/**
+  Set the variable and report the error through status code upon failure.
+
+  @param  VariableName           A Null-terminated string that is the name of the vendor's variable.
+                                 Each VariableName is unique for each VendorGuid. VariableName must
+                                 contain 1 or more characters. If VariableName is an empty string,
+                                 then EFI_INVALID_PARAMETER is returned.
+  @param  VendorGuid             A unique identifier for the vendor.
+  @param  Attributes             Attributes bitmask to set for the variable.
+  @param  DataSize               The size in bytes of the Data buffer. Unless the EFI_VARIABLE_APPEND_WRITE,
+                                 or EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS attribute is set, a size of zero
+                                 causes the variable to be deleted. When the EFI_VARIABLE_APPEND_WRITE attribute is
+                                 set, then a SetVariable() call with a DataSize of zero will not cause any change to
+                                 the variable value (the timestamp associated with the variable may be updated however
+                                 even if no new data value is provided,see the description of the
+                                 EFI_VARIABLE_AUTHENTICATION_2 descriptor below. In this case the DataSize will not
+                                 be zero since the EFI_VARIABLE_AUTHENTICATION_2 descriptor will be populated).
+  @param  Data                   The contents for the variable.
+
+  @retval EFI_SUCCESS            The firmware has successfully stored the variable and its data as
+                                 defined by the Attributes.
+  @retval EFI_INVALID_PARAMETER  An invalid combination of attribute bits, name, and GUID was supplied, or the
+                                 DataSize exceeds the maximum allowed.
+  @retval EFI_INVALID_PARAMETER  VariableName is an empty string.
+  @retval EFI_OUT_OF_RESOURCES   Not enough storage is available to hold the variable and its data.
+  @retval EFI_DEVICE_ERROR       The variable could not be retrieved due to a hardware error.
+  @retval EFI_WRITE_PROTECTED    The variable in question is read-only.
+  @retval EFI_WRITE_PROTECTED    The variable in question cannot be deleted.
+  @retval EFI_SECURITY_VIOLATION The variable could not be written due to EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACESS
+                                 being set, but the AuthInfo does NOT pass the validation check carried out by the firmware.
+
+  @retval EFI_NOT_FOUND          The variable trying to be updated or deleted was not found.
+**/
+EFI_STATUS
+BdsDxeSetVariableAndReportStatusCodeOnError (
+  IN CHAR16    *VariableName,
+  IN EFI_GUID  *VendorGuid,
+  IN UINT32    Attributes,
+  IN UINTN     DataSize,
+  IN VOID      *Data
+  )
+{
+  EFI_STATUS                 Status;
+  EDKII_SET_VARIABLE_STATUS  *SetVariableStatus;
+  UINTN                      NameSize;
+
+  Status = gRT->SetVariable (
+                  VariableName,
+                  VendorGuid,
+                  Attributes,
+                  DataSize,
+                  Data
+                  );
+  if (EFI_ERROR (Status)) {
+    NameSize          = StrSize (VariableName);
+    SetVariableStatus = AllocatePool (sizeof (EDKII_SET_VARIABLE_STATUS) + NameSize + DataSize);
+    if (SetVariableStatus != NULL) {
+      CopyGuid (&SetVariableStatus->Guid, VendorGuid);
+      SetVariableStatus->NameSize   = NameSize;
+      SetVariableStatus->DataSize   = DataSize;
+      SetVariableStatus->SetStatus  = Status;
+      SetVariableStatus->Attributes = Attributes;
+      CopyMem (SetVariableStatus + 1, VariableName, NameSize);
+      CopyMem (((UINT8 *)(SetVariableStatus + 1)) + NameSize, Data, DataSize);
+
+      REPORT_STATUS_CODE_EX (
+        EFI_ERROR_CODE,
+        PcdGet32 (PcdErrorCodeSetVariable),
+        0,
+        NULL,
+        &gEdkiiStatusCodeDataTypeVariableGuid,
+        SetVariableStatus,
+        sizeof (EDKII_SET_VARIABLE_STATUS) + NameSize + DataSize
+        );
+
+      FreePool (SetVariableStatus);
+    }
+  }
+
+  return Status;
+}
diff --git a/Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/HwErrRecSupport.c b/Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/HwErrRecSupport.c
new file mode 100644
index 0000000000..085beb9ba8
--- /dev/null
+++ b/Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/HwErrRecSupport.c
@@ -0,0 +1,42 @@
+/** @file
+  Set the level of support for Hardware Error Record Persistence that is
+  implemented by the platform.
+
+Copyright (c) 2007 - 2018, Intel Corporation. All rights reserved.<BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#include "HwErrRecSupport.h"
+
+/**
+  Set the HwErrRecSupport variable contains a binary UINT16 that supplies the
+  level of support for Hardware Error Record Persistence that is implemented
+  by the platform.
+
+**/
+VOID
+InitializeHwErrRecSupport (
+  VOID
+  )
+{
+  EFI_STATUS  Status;
+  UINT16      HardwareErrorRecordLevel;
+
+  HardwareErrorRecordLevel = PcdGet16 (PcdHardwareErrorRecordLevel);
+
+  if (HardwareErrorRecordLevel != 0) {
+    //
+    // If level value equal 0, no need set to 0 to variable area because UEFI specification
+    // define same behavior between no value or 0 value for L"HwErrRecSupport".
+    //
+    Status = gRT->SetVariable (
+                    L"HwErrRecSupport",
+                    &gEfiGlobalVariableGuid,
+                    EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS | EFI_VARIABLE_NON_VOLATILE,
+                    sizeof (UINT16),
+                    &HardwareErrorRecordLevel
+                    );
+    ASSERT_EFI_ERROR (Status);
+  }
+}
diff --git a/Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/HwErrRecSupport.h b/Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/HwErrRecSupport.h
new file mode 100644
index 0000000000..954f562be2
--- /dev/null
+++ b/Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/HwErrRecSupport.h
@@ -0,0 +1,26 @@
+/** @file
+  Set the level of support for Hardware Error Record Persistence that is
+  implemented by the platform.
+
+Copyright (c) 2007 - 2015, Intel Corporation. All rights reserved.<BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef _HW_ERR_REC_SUPPORT_H_
+#define _HW_ERR_REC_SUPPORT_H_
+
+#include "Bds.h"
+
+/**
+  Set the HwErrRecSupport variable contains a binary UINT16 that supplies the
+  level of support for Hardware Error Record Persistence that is implemented
+  by the platform.
+
+**/
+VOID
+InitializeHwErrRecSupport (
+  VOID
+  );
+
+#endif
diff --git a/Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/Language.c b/Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/Language.c
new file mode 100644
index 0000000000..c17aee2154
--- /dev/null
+++ b/Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/Language.c
@@ -0,0 +1,204 @@
+/** @file
+  Language settings
+
+Copyright (c) 2004 - 2018, Intel Corporation. All rights reserved.<BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#include "Bds.h"
+#define ISO_639_2_ENTRY_SIZE  3
+
+/**
+  Check if lang is in supported language codes according to language string.
+
+  This code is used to check if lang is in in supported language codes. It can handle
+  RFC4646 and ISO639 language tags.
+  In ISO639 language tags, take 3-characters as a delimitation to find matched string.
+  In RFC4646 language tags, take semicolon as a delimitation to find matched string.
+
+  For example:
+    SupportedLang  = "engfraengfra"
+    Iso639Language = TRUE
+    Lang           = "eng", the return value is "TRUE", or
+    Lang           = "chs", the return value is "FALSE".
+  Another example:
+    SupportedLang  = "en;fr;en-US;fr-FR"
+    Iso639Language = FALSE
+    Lang           = "en", the return value is "TRUE", or
+    Lang           = "zh", the return value is "FALSE".
+
+  @param  SupportedLang               Platform supported language codes.
+  @param  Lang                        Configured language.
+  @param  Iso639Language              A bool value to signify if the handler is operated on ISO639 or RFC4646.
+
+  @retval TRUE  lang is in supported language codes.
+  @retval FALSE lang is not in supported language codes.
+
+**/
+BOOLEAN
+IsLangInSupportedLangCodes (
+  IN  CHAR8    *SupportedLang,
+  IN  CHAR8    *Lang,
+  IN  BOOLEAN  Iso639Language
+  )
+{
+  UINTN  Index;
+  UINTN  CompareLength;
+  UINTN  LanguageLength;
+
+  if (Iso639Language) {
+    CompareLength = ISO_639_2_ENTRY_SIZE;
+    for (Index = 0; Index < AsciiStrLen (SupportedLang); Index += CompareLength) {
+      if (AsciiStrnCmp (Lang, SupportedLang + Index, CompareLength) == 0) {
+        //
+        // Successfully find the Lang string in SupportedLang string.
+        //
+        return TRUE;
+      }
+    }
+
+    return FALSE;
+  } else {
+    //
+    // Compare RFC4646 language code
+    //
+    for (LanguageLength = 0; Lang[LanguageLength] != '\0'; LanguageLength++) {
+    }
+
+    for ( ; *SupportedLang != '\0'; SupportedLang += CompareLength) {
+      //
+      // Skip ';' characters in SupportedLang
+      //
+      for ( ; *SupportedLang != '\0' && *SupportedLang == ';'; SupportedLang++) {
+      }
+
+      //
+      // Determine the length of the next language code in SupportedLang
+      //
+      for (CompareLength = 0; SupportedLang[CompareLength] != '\0' && SupportedLang[CompareLength] != ';'; CompareLength++) {
+      }
+
+      if ((CompareLength == LanguageLength) &&
+          (AsciiStrnCmp (Lang, SupportedLang, CompareLength) == 0))
+      {
+        //
+        // Successfully find the Lang string in SupportedLang string.
+        //
+        return TRUE;
+      }
+    }
+
+    return FALSE;
+  }
+}
+
+/**
+  Initialize Lang or PlatformLang variable, if Lang or PlatformLang variable is not found,
+  or it has been set to an unsupported value(not one of platform supported language codes),
+  set the default language code to it.
+
+  @param  LangName                    Language name, L"Lang" or L"PlatformLang".
+  @param  SupportedLang               Platform supported language codes.
+  @param  DefaultLang                 Default language code.
+  @param  Iso639Language              A bool value to signify if the handler is operated on ISO639 or RFC4646,
+                                      TRUE for L"Lang" LangName or FALSE for L"PlatformLang" LangName.
+
+**/
+VOID
+InitializeLangVariable (
+  IN CHAR16   *LangName,
+  IN CHAR8    *SupportedLang,
+  IN CHAR8    *DefaultLang,
+  IN BOOLEAN  Iso639Language
+  )
+{
+  CHAR8  *Lang;
+
+  //
+  // Find current Lang or PlatformLang from EFI Variable.
+  //
+  GetEfiGlobalVariable2 (LangName, (VOID **)&Lang, NULL);
+
+  //
+  // If Lang or PlatformLang variable is not found,
+  // or it has been set to an unsupported value(not one of the supported language codes),
+  // set the default language code to it.
+  //
+  if ((Lang == NULL) || !IsLangInSupportedLangCodes (SupportedLang, Lang, Iso639Language)) {
+    //
+    // The default language code should be one of the supported language codes.
+    //
+    ASSERT (IsLangInSupportedLangCodes (SupportedLang, DefaultLang, Iso639Language));
+    BdsDxeSetVariableAndReportStatusCodeOnError (
+      LangName,
+      &gEfiGlobalVariableGuid,
+      EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS,
+      AsciiStrSize (DefaultLang),
+      DefaultLang
+      );
+  }
+
+  if (Lang != NULL) {
+    FreePool (Lang);
+  }
+}
+
+/**
+  Determine the current language that will be used
+  based on language related EFI Variables.
+
+  @param LangCodesSettingRequired - If required to set LangCodes variable
+
+**/
+VOID
+InitializeLanguage (
+  BOOLEAN  LangCodesSettingRequired
+  )
+{
+  EFI_STATUS  Status;
+  CHAR8       *LangCodes;
+  CHAR8       *PlatformLangCodes;
+
+  LangCodes         = (CHAR8 *)PcdGetPtr (PcdUefiVariableDefaultLangCodes);
+  PlatformLangCodes = (CHAR8 *)PcdGetPtr (PcdUefiVariableDefaultPlatformLangCodes);
+  if (LangCodesSettingRequired) {
+    if (!FeaturePcdGet (PcdUefiVariableDefaultLangDeprecate)) {
+      //
+      // UEFI 2.1 depricated this variable so we support turning it off
+      //
+      Status = gRT->SetVariable (
+                      L"LangCodes",
+                      &gEfiGlobalVariableGuid,
+                      EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS,
+                      AsciiStrSize (LangCodes),
+                      LangCodes
+                      );
+      //
+      // Platform needs to make sure setting volatile variable before calling 3rd party code shouldn't fail.
+      //
+      ASSERT_EFI_ERROR (Status);
+    }
+
+    Status = gRT->SetVariable (
+                    L"PlatformLangCodes",
+                    &gEfiGlobalVariableGuid,
+                    EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS,
+                    AsciiStrSize (PlatformLangCodes),
+                    PlatformLangCodes
+                    );
+    //
+    // Platform needs to make sure setting volatile variable before calling 3rd party code shouldn't fail.
+    //
+    ASSERT_EFI_ERROR (Status);
+  }
+
+  if (!FeaturePcdGet (PcdUefiVariableDefaultLangDeprecate)) {
+    //
+    // UEFI 2.1 depricated this variable so we support turning it off
+    //
+    InitializeLangVariable (L"Lang", LangCodes, (CHAR8 *)PcdGetPtr (PcdUefiVariableDefaultLang), TRUE);
+  }
+
+  InitializeLangVariable (L"PlatformLang", PlatformLangCodes, (CHAR8 *)PcdGetPtr (PcdUefiVariableDefaultPlatformLang), FALSE);
+}
diff --git a/Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/Language.h b/Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/Language.h
new file mode 100644
index 0000000000..300e1eabcb
--- /dev/null
+++ b/Platform/Intel/PurleyOpenBoardPkg/Override/MdeModulePkg/Universal/BdsDxe/Language.h
@@ -0,0 +1,24 @@
+/** @file
+  Language setting
+
+Copyright (c) 2004 - 2015, Intel Corporation. All rights reserved.<BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef _LANGUAGE_H_
+#define _LANGUAGE_H_
+
+/**
+  Determine the current language that will be used
+  based on language related EFI Variables.
+
+  @param LangCodesSettingRequired If required to set LangCode variable
+
+**/
+VOID
+InitializeLanguage (
+  BOOLEAN  LangCodesSettingRequired
+  );
+
+#endif // _LANGUAGE_H_
-- 
2.38.1.windows.1

